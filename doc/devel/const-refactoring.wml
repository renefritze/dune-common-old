# -*- html -*-
# $Id$

#use wml::layout::default title="DUNE - Howto adapt yout grid to the new Interface"

	<h1> How to adapt Your Grid to the New Interface</h1>

	<h2>The Grid</h2>
	<ol>
	  <li>
		<p>
		  The different classes defining one grid implementation are all 
		  provided by the main grid class and not via template
		  parameters.
		</p>
		<p>
		  The grid provides the codim struct which informs about the
		  real implementation of Iterators, Entity, etc.
		</p>
		<p>
		  To ease the definition of the codim struct and to reduce the
		  danger of coding errors we have a GridTraits struct which is
		  parametrized with the implementations:
		</p>
		<pre>
class SuperGrid :
  public GridDefault &lt;dim,dimworld,SuperGrid_ctype,SuperGrid&gt;
    {
    public:
      typedef GridTraits&lt;dim,dimworld,Dune::SuperGrid, SuperGeometry,SuperEntity,
                         SuperBoundaryEntity,SuperLevelIterator,
                         SuperIntersectionIterator,SuperHierarchicIterator&gt; Traits;
       ...
    };
		</pre>
	  </li>
	  <li>
		<p>
		  The mark method is moved into the grid. If your Grid
		  implements a mark method the interface is as follows:
		</p>
		<pre>
  bool mark(int refCount, typename Traits::template codim&lt;0&gt;::EntityPointer &amp; e )
  {
    ...
  }
		</pre>
		<p>
		  Now the grid is the only mutable class in the whole
		  grid interface. This implies that any class (Iterators,
		  Entities, etc.) that needs a reference or a pointer to the
		  grid, should always have it refering to a const Grid.
		</p>
	  </li>
	  <li>
		<p>
		  Renamed methods are:
		</p>
		<table>
			<tr>
			  <td> overlap_size() </td>
			  <td> &rarr; </td>
			  <td> overlapSize() </td>
			</tr>
			<tr>
			  <td> ghost_size() </td>
			  <td> &rarr; </td>
			  <td> ghostSize() </td>
			</tr>
		</table>
	  </li>
	</ol>
	
	<h2>Iterators</h2>
	<ol>
	  <li>
		<p>
		  As the grid now provides the types for Iterators, Entity,
		  etc. the template parameters for the Iterators are reduced
		  to:
		</p>
		<pre>
template&lt;int codim,PartitionIteratorType ptype,class GridImp&gt; class LevelIteratorImp;
template&lt;class GridImp&gt; class IntersectionIteratorImp;
template&lt;class GridImp&gt; class HierarchicIteratorImp;
template&lt;class GridImp&gt; class LeafIteratorImp;
		</pre>
	  </li>
	  <li>
		<p>
		  The Iterators are build upon the IteratorFacedes. Instead of
		  all iterator methods only
		</p>
		<pre>
//! prefix increment
void increment() { ... }
//! equality
bool equals(const LevelIteratorImp&lt;codim,pitype,GridImp&gt;&amp; i) const { ... }
//! dereferencing
Entity&amp; dereference() const { ... }
		</pre>
		<p>
		  need to be implemented.
		</p>
	  </li>
	  <li>
		<p>
		  The IntersectionIterator has three different methods to get a
		  normal vector:
		</p>
		<pre>
outerNormal() // any normal the grid can report, length not known
              // (e.g. if only direction of flow needs to be checked)
unitOuterNormal () // normal scaled to length 1 (for flow value)

integrationOuterNormal () // for integration, named after "integration_element"
		</pre>
		<p>
		  You only need to write an outerNormal method. GridDefault
		  provides default implementations for the other two. You are
		  still free to overwrite these implementations with faster ones.
		</p>
	  </li>
	  <li>
		<p>
		  intersection_neighbor_global and intersection_self_global are
		  the same, so we changed the name to intersectionGlobal to
		  reflect this fact.
		</p>
		<p>
		  intersection_self_local and intersection_neighbor_local are
		  renamed to intersectionSelfLocal and
		  intersectionNeighborLocal to follow the naming convention.
		</p>
		<p>
		  intersection???Local and intersectionGlobal all return an
		  Element but with different dimension parameters because it
		  is once in global and once in local coordinates. We have new
		  typedefs defining the right return value to reduce the
		  danger of coding errors.
		</p>
		<pre>
template&lt;class GridImp&gt;
class IntersectionIteratorImp
{
  ...
public:
  ...
  typedef typename GridImp::template codim&lt;1&gt;::Geometry Geometry;
  typedef typename GridImp::template codim&lt;1&gt;::LocalGeometry LocalGeometry;
  ...
  const LocalGeometry& intersectionSelfLocal () const { ... }
  const LocalGeometry& intersectionNeighborLocal () const { ... }
  const Geometry& intersectionGlobal () const { ... }
};
		</pre>
	  </li>
	</ol>

	<h2>Entity</h2>
	<ol>
	  <li>
		<p>
		  As for the Iterators the template parameters for the Entity 
		  are also reduced:
		</p>
		<pre>
template&lt;int codim,int dim,class GridImp&gt; class EntityImp;
		</pre>
	  </li>
	  <li>
		<p>
		  The Entity offers several dimension enumerations:
		</p>
		<ul>
		  <li>
			codimension // own codimension
		  </li>
		  <li>
			dimension // grid dimension
		  </li>
		  <li>
			mydimension // own dimension
		  </li>
		  <li>
			dimensionworld // dimension of world
		  </li>
		</ul>
	  </li>
	  <li>
		<p>
		  mark() has moved into the grid.
		</p>
	  </li>
	  <li>
		<p>
		  Instead of hasChildren() the entity has the method
		  isLeaf() with inverted return value.
		</p>
	  </li>
	  <li>
		<p>
		  In Entity&lt;0&gt; following methods are renamed:
		</p>
		<table>
			<tr>
			  <td> partition_type() </td>
			  <td> &rarr; </td>
			  <td> partitionType() </td>
			</tr>
			<tr>
			  <td> global_index() </td>
			  <td> &rarr; </td>
			  <td> globalIndex() </td>
			</tr>
			<tr>
			  <td> father_relative_local() </td>
			  <td> &rarr; </td>
			  <td> geometryInFather() </td>
			</tr>
		</table>
		<p>
		  In Entity&lt;dim&gt; following methods are renamed:
		</p>
		<table>
			<tr>
			  <td> father() </td>
			  <td> &rarr; </td>
			  <td> ownersFather() </td>
			</tr>
			<tr>
			  <td> local() </td>
			  <td> &rarr; </td>
			  <td> positionInOwnersFather() </td>
			</tr>
		</table>
	  </li>
	</ol>

	<h2>Element</h2>
	<ol>
	  <li>
		<p>
		  The Element is now named Geometry.
		</p>
	  </li>
	  <li>
		<p>
		  Again the template parameters have changed. A GeometryObject
		  is not bound to the grid, it only has its own dimension and
		  a dimension for its coordinates. The new template paramters
		  are:
		</p>
		<pre>
template&lt;int mydim, int coorddim, class GridImp&gt; class GeometryImp;
		</pre>
	  </li>
	  <li>
		<p>
		  Two methods are renamed:
		</p>
		<table>
			<tr>
			  <td> integration_element() </td>
			  <td> &rarr; </td>
			  <td> integrationElement() </td>
			</tr>
			<tr>
			  <td> Jacobian_inverse() </td>
			  <td> &rarr; </td>
			  <td> jacobianInverse() </td>
			</tr>
		</table>
	  </li>
	</ol>

	<h2>Applications</h2>
	<ol>
	  <li>
		<p>
		  On the application side the biggest change is that
		  Grid::Traits&lt;cd&gt; is now called Grid::codim&lt;cd&gt;.
		</p>
		<p>
		  The next point is to rename according to the method and
		  class name changes mentioned above.
		</p>
		<p>
		  In order to help you rename all the methods and class
		  identifiers Thimo wrote a small script dune/bin/idrename.
		  <strong>No warranty! Please backup your data before using
		  the script!</strong>
		</p>
		<p>
		  For most of the name changes we already have a 
		  <a href="replacements">file</a>
		  describing the renames. For obvious reasons the renaming for
		  local and father is not included.
		</p>
	  </li>
	</ol>

