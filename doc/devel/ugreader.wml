# -*- html -*-
# $Id$

#use wml::layout::default title="DUNE - UGGrid file reader"

<h1> How to Write a File Reader for UGGrid Objects </h1>

<p>
If you want to write a routine that reads a grid from some
file into a Dune UGGrid object you have to know how to use the UGGrid
grid creation interface.  This interface, being under construction,
still reflects a few of the idiosyncracies of the underlying UG
grid management system.  It is nevertheless fairly easy to use.
</p>

<p>
This little text will point out the steps that are necessary
in order to create a UGGrid object.  In the following we
assume that you have a grid in some file format and an
empty UGGrid object, created by one of its constructors.
Hence, your file reader method signature may look like this:
</p>

<pre>
void readMyFileFormat(Dune::UGGrid&lt;3,3&gt;& grid, const std::string& filename)
</pre>

Now, in order to create a valid UGGrid object do the
following steps:

<h2> 1) Start the Creation Process </h2>
<p>
      First of all you have to call
<pre>
grid.createbegin();
</pre>
    This will set up the internal grid creation process.

<h2> 2) Create a Domain </h2>
<p>
      Next, you have to create a 'Domain'.  In UG-speak, this is the
      description of the <i>boundary</i> of your computational domain.  In
      2D it consists of vertices and edges, in 3d of vertices and
      triangles and/or quadrilaterals.  Call the method
</p>

<pre>
grid.createDomain(int numberOfNodes, int numberOfSegments);
</pre>  	

<p>
With the two parameters, you tell the grid the number of nodes and segments
of the <i>boundary</i> of the grid.  Currently, the UGGrid is not able to
extract this information from the set of vertices and elements.  This will
change eventually, though.
</p>

<h2> 3) Build the Domain </h2>

<p>
Next you have to fill in the boundary segments.  For each boundary segment you 
have two options.
</p>

<p>
The first possibility is to have affine boundary segments.  That means that
in 2d, a boundary segment is simply a line between two vertices, and in
3d it's a flat triangle or quadrilateral.  If this is your choice, enter
such a segment by calling
</p>

<pre>
grid.insertLinearSegment(const std::vector&lt; int&gt; &vertices, 
                         const std::vector&lt; FieldVector&lt; double, dimworld &gt; &gt; &coordinates);
</pre>

<p>
The vector <i>vertices</i> must contain the indices of the vertices the current
boundary segment connects.  Indices are counted starting from 0.  The
argument <i>coordinates</i> must contain the corresponding coordinates.
For the time being, these are not extracted from the overall vertex list.
</p>

<p>
The second possibility is to have curved boundary segments.  This means that
the coarse grid is still bounded by a polygon, however, as the grid gets refined,
the finer grids approximate the curved boundary.  
In order to create such boundary segments, for each segment you have to write
a class which implements the correct geometry.  These classes are then handed
over to the UGGrid object.  Boundary segment implementations must be derived
from
<pre>
    template &lt;int dimworld&gt; Dune::BoundarySegment
</pre>
This is an abstract base class which requires you to overload the method

<pre>
virtual FieldVector&lt; double, dimworld &gt; operator() (const FieldVector&lt; double, dimworld-1 &gt; &local)
</pre>

<p>
This methods must compute the world coordinates from the local ones on the
boundary segment.  Give these classes to your grid by calling
</p>
<pre>
grid.insertBoundarySegment(const std::vector&lt;int&gt;& vertices, 
                           const BoundarySegment&lt;dimworld&gt; *boundarySegment);
</pre>
    
<p>
Control over the allocated objects is taken from you, and the grid object
will take care of their destruction.
</p>

<h2> 4)  Enter the Inner Vertices </h2>

<p>
Now you have to enter the grid vertices.  As UG has already
created the boundary vertices all you need to do is enter the
remaining ones.  Note that if your input file doesn't contain
the vertices in an boundary -- interior order you are
implicitly reordering your vertices and you'll have to adjust
your elements accordingly.
</p>

<p>
Create an inner vertex by calling
</p>

<pre>
grid.insertVertex(const FieldVector&lt;double,dimworld&gt;& position);
</pre>

<h2> 5) Enter the elements </h2>

<p>
For each element call
</p>

<pre>
grid.insertElement(Dune::GeometryType type, const std::vector&lt;int&gt;& vertices);
</pre>  	

<p>
The parameters are
</p>

<ul>
      <li> <b>type</b> - The element type.  UG supports the types <i>simplex</i> and
        <i>cube</i> in 2d, and <i>simplex, cube, prism</i>, and <i>pyramid</i> in 3d.
      <li> <b>vertices</b> - The Ids of the vertices of this element.</li>
</ul>

<p>
The numbering of the vertices of each element is expected to follow the DUNE conventions.
Refer to the page on reference elements for the details.

<h2> 6) Finish construction </h2>

<p>
To finish off the construction of the UGGrid object call
</p>

<pre>
grid.createend();
</pre>

<h2> Loading a Grid on a Parallel Machine </h2>
<p>
If you're working on a parallel machine, and you want to set up a
parallel grid, proceed as described on all processes.  This will
create the grid on the master process and set up UG correctly on all
other process.  Call loadBalance to actually distribute the grid.
</p>

<p>
Good luck!  Remember that DUNE is still in an unstable state and that
any interface, method or class may change without much notice.
Subscribe to the DUNE mailing list for newest information.
</p>

<p>
Mail comments, critique, and corrections to sander@math.fu.berlin.de.
</p>
