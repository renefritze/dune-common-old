# -*- html -*-
# $Id$

#use wml::layout::default title="DUNE - UGGrid file reader"

<h1> How to Write a File Reader for UGGrid Objects </h1>

<p>
If you want to write a routine that reads a grid from some
file into a Dune UGGrid object you have to know how to use the UGGrid
grid creation interface.  In the following we
assume that you have a grid in some file format and an
empty UGGrid object, created by one of its constructors.
Hence, your file reader method signature may look like this:
</p>

<pre>
void readMyFileFormat(Dune::UGGrid&lt;3,3&gt;& grid, const std::string& filename)
</pre>

Now, in order to create a valid UGGrid object do the
following steps:

<h2> 1) Start the Creation Process </h2>
<p>
      First of all you have to call
<pre>
grid.createbegin();
</pre>
    This will set up the internal grid creation process.

<h2> 2)  Enter the Vertices </h2>

<p>
Now you have to enter the grid vertices.  Create a vertex by calling
</p>

<pre>
grid.insertVertex(const FieldVector&lt;double,dimworld&gt;& position);
</pre>

<h2> 3) Enter the elements </h2>

<p>
For each element call
</p>

<pre>
grid.insertElement(Dune::GeometryType type, const std::vector&lt;int&gt;& vertices);
</pre>  	

<p>
The parameters are
</p>

<ul>
      <li> <b>type</b> - The element type.  UG supports the types <i>simplex</i> and
        <i>cube</i> in 2d, and <i>simplex, cube, prism</i>, and <i>pyramid</i> in 3d.
      <li> <b>vertices</b> - The Ids of the vertices of this element.</li>
</ul>

<p>
The numbering of the vertices of each element is expected to follow the DUNE conventions.
Refer to the page on reference elements for the details.

<h2> 4) Parametrized Domains </h2>

<p>
UGGrid supports parametrized domains.  That means that you can provide a
smooth description of your grid boundary.  The actual grid will always
be piecewise linear; however, as you refine, the grid will approach your
prescribed boundary.  You don't have to do this.  If your
coarse grid boundary describes your domain well read on at Section 5.
</p>

<p>
In order to create curved boundary segments, for each segment you have to write
a class which implements the correct geometry.  These classes are then handed
over to the UGGrid object.  Boundary segment implementations must be derived
from
<pre>
    template &lt;int dimworld&gt; Dune::BoundarySegment
</pre>
This is an abstract base class which requires you to overload the method

<pre>
virtual FieldVector&lt; double, dimworld &gt; operator() (const FieldVector&lt; double, dimworld-1 &gt; &local)
</pre>

<p>
This methods must compute the world coordinates from the local ones on the
boundary segment.  Give these classes to your grid by calling
</p>
<pre>
grid.insertBoundarySegment(const std::vector&lt;int&gt;& vertices, 
                           const BoundarySegment&lt;dimworld&gt; *boundarySegment);
</pre>
    
<p>
Control over the allocated objects is taken from you, and the grid object
will take care of their destruction.
</p>

<h2> 6) Finish construction </h2>

<p>
To finish off the construction of the UGGrid object call
</p>

<pre>
grid.createend();
</pre>

<h2> Loading a Grid on a Parallel Machine </h2>
<p>
If you're working on a parallel machine, and you want to set up a
parallel grid, proceed as described on all processes.  This will
create the grid on the master process and set up UG correctly on all
other process.  Call <tt>loadBalance()</tt> to actually distribute the grid.
</p>

<p>
<b>WARNING:</b> UG internally requests that all boundary vertices be
inserted before the inner ones.  That means that if your input grid
doesn't comply with this, it will have its vertices reordered by
<tt>createend()</tt>.  So don't be surprised if you just read a grid and write
it back to disk to find your vertex numberings changed.
</p>

<p>
Mail comments, critique, and corrections to sander@math.fu.berlin.de.
</p>
