# -*- html -*-
# $Id$

#use wml::layout::default title="DUNE - Documentation - Buildsystem"


<h1>Using the DUNE build-system</h1>

<h2>Overview</h2>
<ol>	
<li>Rationale (why the autotools?)</li>
<li>small Makefile.am tutorial</li>
<li>How do I... (recipes for common actions)</li>
</ol>

<h2>Rationale</h2>

<em>insert better text</em>

<ul>
<li>we need platform independent build</li>
<li>check which features are present -> autoconf</li>
<li>build libraries on all platforms -> libtool</li>
<li>create portable but flexible Makefiles -> automake</li>
</ul>

<h2>small Makefile.am tutorial</h2>

<h3>Building programs</h3>

<p>
Let's start off with a simple program "hello" built from "hello.c". As
automake is designed to build and install a package it needs to know
</p>

<ul>
<li>what programs it should build</li>
<li>where to put them when installing</li>
<li>which sources to use</li>
</ul>

<p>
The Makefile.am thus looks like this:
</p>

<pre>
 noinst_PROGRAMS = hello
 hello_SOURCES = hello.c
</pre>

<p>
This would build hello and won't install it when "make install" is
called. Using "bin_PROGRAMS" instead of "noinst_PROGRAMS" would install
the hello-binary into a standard-"bin"-directory which we don't want
to do with most of the DUNE-applications :)
</p>

<p>
Building more programs with a couple of source-files works like this
</p>

<pre>
 noinst_PROGRAMS = hello bye

 hello_SOURCES = common.c common.h hello.c 
 bye_SOURCES = common.c common.h bye.c parser.y lexer.l
</pre>

<p>
automake has more integrated rules than the standard make, the example
above would automatically use yacc/lex to create parser.c/lexer.c and
build them into the "bye"-binary.
</p>

<p>
Make-Variables may be defined and used as usual:
</p>

<pre>
 noinst_PROGRAMS = hello bye

 COMMON = common.c common.h

 hello_SOURCES = $(COMMON) hello.c 
 bye_SOURCES = $(COMMON) bye.c parser.y lexer.l
</pre>

<p>
Even normal make-rules may be used in a Makefile.am
</p>


<h3>Using flags</h3>

<p>
Compiler/linker/preprocessor-flags can be set either globally:
</p>

<pre>
 noinst_PROGRAMS = hello bye

 AM_CPPFLAGS = -DDEBUG

 hello_SOURCES = hello.c 
 bye_SOURCES = bye.c
</pre>

<p>
or locally:
</p>

<pre>
 noinst_PROGRAMS = hello bye

 hello_SOURCES = hello.c 
 hello_CPPFLAGS = -DHELLO

 bye_SOURCES = bye.c
 bye_CPPFLAGS = -DBYE
</pre>

<p>
The local setting overrides the global one, thus
</p>

<pre>
 hello_CPPFLAGS = $(AM_CPPFLAGS) -Dmyflags
</pre>

<p>
may be a good idea.
</p>

<p>
It is even possible to compile the same sources with different flags:
</p>

<pre>
 noinst_PROGRAMS = hello bye

 hello_SOURCES = generic-greeting.c
 hello_CPPFLAGS = -DHELLO

 bye_SOURCES = generic-greeting.c
 bye_CPPFLAGS = -DBYE
</pre>

<p>
Perhaps you're wondering why the above examples used AM_CPPFLAGS
instead of the normal CPPFLAGS? The reason for this is that the
variables CFLAGS, CPPFLAGS, CXXFLAGS etc. are considered "user
variables" which may be set on the commandline:
</p>

<pre>
  make CXXFLAGS="-O2000"
</pre>

<p>
This would override any settings in Makefile.am which might be
necessary to build. Thus, if the variables should be set even if the
user wishes to modify the values, you should use the AM_* version.
</p>

<p>
The real compile-command always uses both AM_VAR and VAR. Options that
autoconf finds are stored in the user variables (so that they may be
overridden)
</p>

<p>
Commonly used variables are:
</p>

<table>
<tr><th>Variable</th><th>Description</th></tr>
<tr>
<td>AM_CPPFLAGS</td><td>flags for the C-Preprocessor. This includes
               preprocessor-defines like -DNDEBUG and include-pathes
               like -I/usr/local/package/include</td></tr>
<tr>
<td>AM_CFLAGS, 
 AM_CXXFLAGS</td>
<td>flags for the compiler (-g, -O, ...). One difference
               between these and the CPPFLAGS is that the linker will
               get CFLAGS/CXXFLAGS and LDFLAGS but not CPPFLAGS</td></tr>

<tr>
<td>AM_LDFLAGS</td><td>options for the linker</td></tr>

<tr>
<td>LDADD</td><td>libraries to link to a binary</td></tr>

<tr>
<td>LIBADD</td><td>libraries to add to a library</td></tr>

<tr>
<td>SOURCES</td><td>list of source-files (may include headers as well)</td></tr>
</table>
 

<h3>Conditional builds</h3>

<p>
Some parts of DUNE only make sense if certain addon-packages were
found. autoconf therefore defines "conditionals" which automake can
use:
</p>

<pre>
  if OPENGL
    PROGS = hello glhello
  else
    PROGS = hello
  endif

  hello_SOURCES = hello.c

  glhello_SOURCES = glhello.c hello.c
</pre>

<p>
This will only build the "glhello"-program if OpenGL was found. An
important feature of these conditionals is that they work with any
make program, even those without a native "if"-construct like
GNU-make.
</p>


<h3>default targets</h3>

<p>
An automake-generated Makefile does not only know the usual "all",
"clean" and "install" targets but also
</p>

<table>
<tr>
<td>tags</td><td>       travel recursively through the directories and create
             TAGS-files which can be used in many editors to quickly
             find where symbols/functions are defined (use emacs-format)</td></tr>

<tr>
<td>ctags</td><td>the same as "tags" but uses the vi-format for the
             tags-files</td></tr>
<tr>
<td>dist</td><td>create a distribution tarball</td></tr>

<tr>
<td>distcheck</td><td>create a tarball and do a test-build if it really works</td></tr>
</table>


<h2>How do I...</h2>

<dl>
<dt>... set my favourite compiler-options?</dt>
<dd>
 <p>
 As the Makefiles should work on any system you must not include
 compiler-specific options into those. However there are two ways to
 pass special flags to the compiler:</p>

 <ol>
 <li> <strong>use a .opts-file</strong>
      
   You may copy gcc.opts or icc.opts to a different file, set
   arbitrary compiler-commands/options and pass it to autogen.sh via
   the --opts=OPTFILE parameter. This will add the options into your
   Makefiles. This is the best way for global options you want to use
   for developing.</li>

 <li> <strong>pass flags via commandline</strong>

   If you want to use special flags locally or just for a couple of
   builds you can set them as make-parameters, e.g.

   <pre>
  make CXXFLAGS="-O5 -march=pentium2000"
   </pre> 

   This setting is recursively passed on into the subdirs.</li>
   </ol> 
</dd>

<dt>... add new directories?</dt>

<dd>
  <p>When you add a new directory you have to do the following:</p>

  <ol>
  <li>create a Makefile.am in the new directory (e.g. by copying)</li>

  <li>add the new directory to the SUBDIRS in the Makefile.am above so
     that the full build enters the new location</li>

  <li>add the new Makefile to the AC_CONFIG_FILES-section in
     configure.ac in the applications base-directory so that autoconf
     generates it</li>

  <li>run ./autogen.sh</li>
  </ol>

  <p>
  Now a "Makefile.in" and a "Makefile" should have appeared in the new
  directory.</p>
</dd>

<dt>... do stuff not mentioned in this document?</dt>

<dd><p>
 The "Autobook" contains many recipies on how to use the autotools. It
 is available online on <a href="http://sources.redhat.com/autobook/autobook/autobook_toc.html">http://sources.redhat.com/autobook/autobook/autobook_toc.html</a> Additionally, the info-pages of autoconf, automake and libtool
 contain the reference documents for those tools.</p></dd>
</dl>
