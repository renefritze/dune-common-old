\documentclass[11pt,a4paper,headinclude,footinclude,DIV16,normalheadings]{scrartcl}
\usepackage[automark]{scrpage2}
\usepackage[ansinew]{inputenc}
%\usepackage{german}
%\usepackage{bibgerm}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{theorem}
\usepackage{color}
\usepackage{listings}
\lstset{language=bash, basicstyle=\normalfont\ttfamily\scriptsize,
  keywordstyle=\color{black}\bfseries, tabsize=4,
  stringstyle=\ttfamily, commentstyle=\it, extendedchars=true}
\usepackage{hyperref}
\usepackage{psfrag}
\usepackage{pstricks}
\usepackage{makeidx}
\usepackage{xspace}

\usepackage{graphicx}

\newtheorem{lst}{Listing}

\newcommand{\dune}{\texttt{DUNE}\xspace}
\newcommand{\autoconf}{\texttt{autoconf}\xspace}
\newcommand{\automake}{\texttt{automake}\xspace}
\newcommand{\autogen}{\texttt{autogen.sh}\xspace}
\newcommand{\libtool}{\texttt{libtool}\xspace}
\newcommand{\configure}{\texttt{configure}\xspace}
\newcommand{\configureac}{\texttt{configure.ac}\xspace}
\newcommand{\makefile}{\texttt{Makefile}\xspace}
\newcommand{\makefilein}{\texttt{Makefile.in}\xspace}
\newcommand{\makefileam}{\texttt{Makefile.am}\xspace}
\newcommand{\dunecommon}{\texttt{dune-common}\xspace}
\newcommand{\duneistl}{\texttt{dune-istl}\xspace}
\newcommand{\dunegrid}{\texttt{dune-grid}\xspace}
\newcommand{\dunedisc}{\texttt{dune-disc}\xspace}
\newcommand{\dunecontrol}{\texttt{dunecontrol}\xspace}
\newcommand{\dunemodule}{\texttt{dune.module}\xspace}
\newcommand{\make}{\texttt{make}\xspace}

\pagestyle{scrheadings}

\title{The DUNE Buildsystem HOWTO}

\author{Christian Engwer$^\ast$}

\date{\today}

\publishers{%
{\normalsize $^\ast$Interdisziplinäres Zentrum für Wissenschaftliches Rechnen,
Universität Heidelberg,\\
Im Neuenheimer Feld 368, D-69120 Heidelberg, Germany}\\
\bigskip
{\normalsize \texttt{\url{http://www.dune-project.org/}}}\\
}

\begin{document}

\maketitle
\tableofcontents
\pagebreak
\section{Structure of DUNE}
\dune consists of several independent modules:
\begin{itemize}
\item \dunecommon
\item \dunegrid
\item \duneistl
\item \dunedisc
\item \texttt{dune-fem}
\end{itemize}

These modules interact very tightly and depend on each
other.

The build system is structured as follows:
\begin{itemize}
\item Modules are build using the GNU autotools.
\item Each module has a set of modules it depends on, these modules
  have to be built before building the module itself.
\item Each module has a file \dunemodule which hold dependecies and
  other information regarding the module.
\item The modules can be built in the appropriate order using the
  \dunecontrol script (shipped with \dunecommon)
\end{itemize}

The reasons to use the GNU autotools for \dune were the following
\begin{itemize}
\item We need platform independent build.
\item Enabling or disabling of certain features depending on
  features present on the system.
\item Creations of libraries on all platforms.
\item Easy creation of portable but flexible Makefiles.
\end{itemize}

The reasons to add the \dunecontrol script and the \dunemodule
description files were
\begin{itemize}
\item One tool to setup all modules (autotools can only work on one
  module).
\item Automatic dependency tracking.
\item Automatic collection of commandline parameters (\configure needs
  special commandline parameters for all modules it uses)
\end{itemize}

\section{Toolchain}
\subsection{Autotools}

Software is generally developed to be used on multiple
platforms. Since each of these platforms have different compilers,
different include files, there is a need to write Makefiles and build
scripts so that they can work on a variety of platforms. The free
software community (Project GNU), faced with this problem, devised a
set of tools to generate Makefiles and build scripts that work on a
variety of platforms. If you have downloaded and built any GNU
software from source, you are familiar with the \configure script. The
\configure script runs a series of tests to determine information about
your machine.

The autotools simplify the generation of portable Makefiles and
configure scripts.

\minisec{autoconf}

\autoconf is used to create the \configure script. \configure is
created from \configureac, using a set of \texttt{m4} files.

\begin{center}
\psset{unit=0.5mm}
\psset{linewidth=0.4pt}
\begin{pspicture}(140,50)
\put(-26,45){\parbox{40\unitlength}{\centering{}\configureac}}
\put(116,45){\parbox{40\unitlength}{\centering{}\tt{}m4/*.m4}}
\put(0,36)
{
  \psset{linewidth=1pt}
  \psline[linearc=4]{c-}(-2,2)(-2,-2)(67.5,-2)(67.5,-6)
  \psline[linearc=4]{c-}(137,2)(137,-2)(67.5,-2)(67.5,-6)
  \psline{->}(67.5,-5.5)(67.5,-20)
}
\put(72,22){\textit{\autoconf}}
\put(50,7){\parbox{40\unitlength}{\centering{}\configure}}
\end{pspicture}
\end{center}

How to write a \configureac for \dune is described in \ref{configure.ac}

\minisec{automake}

\automake is used to create the \makefilein files (needed for
\configure) from \makefileam files and, using a set of include files
located in the \texttt{am} directory. These include files provide
additional features, not provided by the standard \automake (see
\ref{am_includes}). The \texttt{am} directory is in the \dunecommon
module and each module intending to use one of these includes has to
create symlink; this is usually done by \autogen (see
\ref{autogen.sh}).

\begin{center}
\psset{unit=0.5mm}
\psset{linewidth=0.4pt}
\begin{pspicture}(140,80)
\put(-26,75){\parbox{40\unitlength}{\centering{}\makefileam}}
\put(116,75){\parbox{40\unitlength}{\centering{}\tt{}am/*}}
\put(0,66)
{
  \psset{linewidth=1pt}
  \psline[linearc=4]{c-}(-2,2)(-2,-2)(67.5,-2)(67.5,-6)
  \psline[linearc=4]{c-}(137,2)(137,-2)(67.5,-2)(67.5,-6)
  \psline{->}(67.5,-5.5)(67.5,-20)
}
\put(72,52){\textit{\automake}}
\put(50,37){\parbox{40\unitlength}{\centering{}\texttt{Makefile.in}}}
\put(0,34)
{
  \psset{linewidth=1pt}
  \psline[linestyle=dashed,dash=1.5pt 1.5pt]{->}(67.5,0)(67.5,-14.5)
}
\put(72,25){\textit{\configure}}
\put(50,10){\parbox{40\unitlength}{\centering{}\texttt{Makefile}}}
\end{pspicture}
\end{center}

Information on writing a \makefileam is described in \ref{makefile.am}

\minisec{libtool}
\libtool is a wrapper around the compiler and
linker. It offers a generic interface for creating static and shared
libraries, regardless of the platform it is running on.

\libtool hides all the platform specific aspects of library creation
and library usage. When linking a library or an executable you (or
\automake) can call the compiler via \libtool. \libtool will then take
care of
\begin{itemize}
\item \em platform specific \em commandline parameters for the linker
\item library dependencies
\end{itemize}

\minisec{configure}
\label{configure}
\configure will run the set of tests specified in your \configureac.
Using the results of these tests configure can check that all
necessary features (libs, programs, etc.) are present and can activate
and deactivate certain features of the module depending on the feature
of the system.

For example \configure in \dunegrid will search for the ALUGrid
library and depending on the result enable or disable
\texttt{Dune::ALU3dGrid}.

Many test will also store their results in the \texttt{config.h}
header file. A headerfile can then use an \verb!#ifdef! statement to
disable parts of the code that don't work without a certain
feature. This can be used in the applications aswell as in the headers
in a \dune module. When we stick to the example of the ALUGrid
library \texttt{config.h} will contain a \verb!#define HAVE_ALUGRID!
if ALUGrid was found.

The \texttt{config.h} file is created by configure from a
\texttt{config.h.in} file, which is automatically created from the
list of tests used in the \configureac.

\subsection{Makefile.am}
\label{makefile.am}

\subsubsection{Overview}

Let's start off with a simple program {\em hello} built from
\texttt{hello.c}. As automake is designed to build and install a
package it needs to know

\begin{itemize}
\item what programs it should build
\item where to put them when installing
\item which sources to use
\end{itemize}

The \makefileam thus looks like this:

\begin{lstlisting}[language=make]
noinst_PROGRAMS = hello
hello_SOURCES = hello.c
\end{lstlisting}

This would build hello and won't install it when \texttt{make
  install} is called. Using \verb!bin_PROGRAMS! instead of
\verb!noinst_PROGRAMS! would install the hello-binary into a
\texttt{\textit{prefix}/bin} directory which we don't want to do with
most of the \dune applications.

Building more programs with a couple of source-files works like this

\begin{lstlisting}[language=make]
noinst_PROGRAMS = hello bye

hello_SOURCES = common.c common.h hello.c
bye_SOURCES = common.c common.h bye.c parser.y lexer.l
\end{lstlisting}

automake has more integrated rules than the standard make, the example
above would automatically use yacc/lex to create
\texttt{parser.c/lexer.c} and build them into the {\em bye} binary.

Make-Variables may be defined and used as usual:

\begin{lstlisting}[language=make]
noinst_PROGRAMS = hello bye

COMMON = common.c common.h

hello_SOURCES = $(COMMON) hello.c
bye_SOURCES = $(COMMON) bye.c parser.y lexer.l
\end{lstlisting}

Even normal make-rules may be used in a \makefileam.

\minisec{Using flags}

Compiler/linker/preprocessor-flags can be set either globally:

\begin{lstlisting}[language=make]
noinst_PROGRAMS = hello bye

AM_CPPFLAGS = -DDEBUG

hello_SOURCES = hello.c
bye_SOURCES = bye.c
\end{lstlisting}

or locally:

\begin{lstlisting}[language=make]
noinst_PROGRAMS = hello bye

hello_SOURCES = hello.c
hello_CPPFLAGS = -DHELLO

bye_SOURCES = bye.c
bye_CPPFLAGS = -DBYE
\end{lstlisting}

The local setting overrides the global one, thus

\begin{lstlisting}[language=make]
hello_CPPFLAGS = $(AM_CPPFLAGS) -Dmyflags
\end{lstlisting}

may be a good idea.

It is even possible to compile the same sources with different flags:

\begin{lstlisting}[language=make]
noinst_PROGRAMS = hello bye

hello_SOURCES = generic-greeting.c
hello_CPPFLAGS = -DHELLO

bye_SOURCES = generic-greeting.c
bye_CPPFLAGS = -DBYE
\end{lstlisting}

Perhaps you're wondering why the above examples used
\texttt{AM\_CPPFLAGS} instead of the normal \texttt{CPPFLAGS}? The
reason for this is that the variables \texttt{CFLAGS},
\texttt{CPPFLAGS}, \texttt{CXXFLAGS} etc. are considered {\em user
  variables} which may be set on the commandline:

\begin{lstlisting}[language=make]
make CXXFLAGS="-O2000"
\end{lstlisting}

This would override any settings in Makefile.am which might be
necessary to build. Thus, if the variables should be set even if the
user wishes to modify the values, you should use the \texttt{AM\_*}
version. 

The real compile-command always uses both \texttt{AM\_\textit{VAR}} and
\texttt{\textit{VAR}}. Options that
autoconf finds are stored in the user variables (so that they may be
overridden) 

Commonly used variables are:
\begin{itemize}
\item \texttt{AM\_CPPFLAGS}: flags for the C-Preprocessor. This
  includes preprocessor defines like \texttt{-DNDEBUG} and include
  pathes like \texttt{-I/usr/local/package/include}
\item \texttt{AM\_CFLAGS}, \texttt{AM\_CXXFLAGS}: flags for the
  compiler (-g, -O, ...). One difference between these and the
  \texttt{CPPFLAGS} is that the linker will get
  \texttt{CFLAGS}/\texttt{CXXFLAGS} and \texttt{LDFLAGS} but not
  \texttt{CPPFLAGS}
\item \texttt{AM\_LDFLAGS} options for the linker
\item \texttt{LDADD}: libraries to link to a binary
\item \texttt{LIBADD}: libraries to add to a library
\item \texttt{SOURCES}: list of source-files (may include headers as well)
\end{itemize}

\minisec{Conditional builds}

Some parts of \dune only make sense if certain addon-packages were
found. autoconf therefore defines {\em conditionals} which automake can
use:

\begin{lstlisting}[language=make]
if OPENGL
  PROGS = hello glhello
else
  PROGS = hello
endif

hello_SOURCES = hello.c

glhello_SOURCES = glhello.c hello.c
\end{lstlisting}

This will only build the {\em glhello} program if OpenGL was found. An
important feature of these conditionals is that they work with any
make program, even those without a native {\em if} construct like GNU-make.

\minisec{Default targets}

An automake-generated Makefile does not only know the usual {\em all},
{\em clean} and {\em install} targets but also
\begin{itemize}
\item {\bf tags} travel recursively through the directories and create
  TAGS-files which can be used in many editors to quickly find where
  symbols/functions are defined (use emacs-format)
\item {\bf ctags} the same as "tags" but uses the vi-format for the tags-files
\item {\bf dist} create a distribution tarball
\item {\bf distcheck} create a tarball and do a test-build if it really works
\end{itemize}

\subsubsection{Building Documentation}
\label{am_includes}

If you want to build documentation you might need additional make
rules. \dune offers a set of predefined rules to create certain kinds
of documentation. Therefor you have to include the appropriate rules
from the \texttt{am/} directory. These rules are stored in the
\texttt{dune-common/am/} directory. If you want to use these any of
these rules in your \dune module or application you will have to
create a symbolic link to \texttt{dune-common/am/}. The creation of
this link should be done by the \autogen script.

\minisec{html pages}
Webpages are created from wml sources, using the program \texttt{wml}
(\texttt{\url{http://thewml.org/}}).\\
\texttt{\$(top\_srcdir)/am/webstuff} containes the necessary rules.

\hspace*{-2ex}\begin{minipage}{\textwidth}
\begin{lst}[File Makefile.am] \mbox{}
\lstinputlisting[language=make]{../Makefile.am}
\end{lst}
\end{minipage}

\minisec{\LaTeX documents}
In order to compile \LaTeX documents you can include
\texttt{\$(top\_srcdir)/am/latex}. This way you get rules for creation
of DVI files, PS files and PDF files.

\minisec{SVG graphics}
SVG graphics can be converted to png, in order to include them into
the web page. This conversion can be done using inkscape
(\texttt{\url{http://www.inkscape.org/}}).
\texttt{\$(top\_srcdir)/am/inkscape.am} offers the necessary rules.


\subsection{configure.ac}
\label{configure.ac}

\configureac  is a normal text file that contains several \autoconf
macros. These macros are evaluated my the \texttt{m4} macro processor
and transformed into a shell script.

\begin{lst}[File dune-common/configure.ac] \mbox{}
\lstinputlisting{../../configure.ac}
\end{lst}

We offer a set of macros that can be used in your \configureac:

\begin{itemize}
\item \texttt{DUNE\_CHECK\_ALL\_M}
  runs all checks usually needed by a {\em \dune module}.
  This macros takes list of other \dune modules it should search for
  as parameters.
\begin{lstlisting}[language=make]
DUNE_CHECK_ALL_M([dunecommon], [dunegrid])
\end{lstlisting}
  will search for \texttt{dune-common} and \texttt{dune-grid}
  (Attention: you have to provide the modules in such an order that
  the dependencies are checked already).
\item \texttt{DUNE\_CHECK\_ALL}
  same as \texttt{DUNE\_CHECK\_ALL\_M}, except that it only runs the
  tests needed for a {\em \dune application}
\item \texttt{DUNE\_SUMMARY\_ALL}
  prints information on the results of all major checks run by
  \texttt{DUNE\_CHECK\_ALL} or \texttt{DUNE\_CHECK\_ALL\_M}.
\end{itemize}

\texttt{DUNE\_CHECK\_ALL} and \texttt{DUNE\_CHECK\_ALL\_M} define certain
variables that can be used in the \configure script or in the
\makefileam:

\begin{itemize}
\item \texttt{DUNE\textit{\,MODULE\,}\_CPPFLAGS}
\item \texttt{DUNE\textit{\,MODULE\,}\_LDFLAGS}
\item \texttt{DUNE\textit{\,MODULE\,}\_LIBS}
\item \texttt{DUNE\textit{\,MODULE\,}ROOT}
\end{itemize}

The last step to a complete \configureac is that you tell autoconf
which files should be generated by \configure. Therefor you add an
\texttt{AC\_CONFIG\_FILES([\textit{WhiteSpaceSeparatedListOfFiles}])}
statement to your \configureac. The list of files should be the list
of files that are to be generated, not the input -- i.e. you would
write
\begin{lstlisting}[language=make]
AC_CONFIG_FILES([Makefile doc/Makefile])
\end{lstlisting}
end not
\begin{lstlisting}[language=make]
AC_CONFIG_FILES([Makefile.in doc/Makefile.in])
\end{lstlisting}
After you told \autoconf which files to create you have to actually
trigger their creation with command \texttt{AC\_OUTPUT}

\subsection{autogen.sh}
\label{autogen.sh}

The \autogen script is used to bring the freshly checked out module
into that state that you expect from a module received via the
tarball. That means it runs all necessary stepts so that you can call
\configure to setup your module. In the case of \dune this means that
\autogen runs
\begin{itemize}
\item \texttt{libtoolize} (prepare the module for \libtool)
\item \texttt{aclocal} (collect all \autoconf macros needed for this module)
\item \texttt{autoheader} (create the \texttt{config.h.in})
\item \texttt{automake} (create the \makefilein)
\item \texttt{autoconf} (create \configure)
\end{itemize}

If needed it will also create the symbolic link to the
\texttt{dune-common/am/} directory (see \ref{am_includes}).

\subsection{dunecontrol}
\label{dunecontrol}
\dunecontrol helps you building the different \dune modules in the
appropriate order. Each module has a \dunemodule file which contains
information on the module needed by \dunecontrol. 

\dunecontrol searches for \dunemodule files recursively from where you
are executing the program. For each \dune module found it will execute
a \dunecontrol command. All commands offered by \dunecontrol have a
default implementation. This default implementation can be overwriten
and extended in the \dunemodule file.

The commands you are interested in right now are
\begin{itemize}
\item \texttt{autogen} runs \autogen for each module. A list of
  directories containing \dunemodule files and the parameters given on
  the commandline are passed as paramters to \autogen.
\item \texttt{configure} runs \configure for each
  module. \texttt{--with-dune\textit{module}} parameters are created
  for a set of known \dune modules.
\item \texttt{make} runs \make for each module.
\item \texttt{all} runs \autogen, \configure and \make for each module.
\end{itemize}

In order to build \dune the first time you will need the \texttt{all}
command. In pseudo code \texttt{all} does the following:
\begin{lstlisting}[language=perl]
foreach ($module in $Modules) {
  foreach (command in {autogen,configure,make) {
    run $command in $module
  }
}
\end{lstlisting}

This differs from calling
\begin{lstlisting}
dunecontrol autogen
dunecontrol configure
dunecontrol make
\end{lstlisting}
as it ensures that i.e. \dunecommon is fully built before \configure
is executed in \dunegrid. Otherwise \configure in \dunegrid would
complain that \texttt{libcommon.la} from \dunecommon is missing.

Further more you can add parameters to the commands; these parameters
get passed on to the program being executed. Assuming you want to call
\texttt{make clean} in all \dune modules you can execute
\begin{lstlisting}
dunecontrol make clean
\end{lstlisting}

\minisec{opts files}
You can also let \dunecontrol read the command parameters from a file.
For each command you can specify parameters. The parameters are stored
in a varible called \texttt{\textit{COMMAND}\,\_FLAGS} with
\texttt{\textit{COMMAND}} written in capital letters.

\begin{lst}[File examle.opts] \mbox{}
\lstinputlisting{../example.opts}
\end{lst}

When you specify an opts file and command line paramters
\begin{lstlisting}
dunecontrol --opts=some.opts configure --with-foo=bar
\end{lstlisting}
dunecontrol will ignore the parameters specified in the opts file and
you will get a warning.

\minisec{environment variables}
You can further control the behavior of \dunecontrol by certain
environment variables.
\begin{itemize}
\item \texttt{DUNE\_OPTS\_FILE} specifies the opts file that should be
  read by dunecontrol. This variable will be overwritten by the
  \texttt{--opts=} option.
\item \texttt{MAKE} tells \dunecontrol which command to invoke for
  'make'. This can be useful for exmaple, if you want to use
  \texttt{\textit{gmake}} as a make dropin.
\item \texttt{GREP} tells \dunecontrol which command to invoke for 'grep'.
\end{itemize}

\minisec{dune.module}

The \dunemodule file is split into two parts. First we have the
parameter section where you specify parameters describing the module.
Then we have the command section where you can overload the default
implementation of a command called via \dunecontrol.

\begin{lst}[File dune.module] \mbox{}
\begin{lstlisting}
# paramters for dune control
Module: dune_grid
Depends: dune_common
Suggests: UG Alberta Alu3d

# overload the run_configure command
run_configure () {
  # lets extend the paramter list $PARAMS
  if test "x$HAVE_UG" == "xyes"; then
    PARAMS="$PARAMS \"--with-ug=$PATH_UG\""
  fi
  if test "x$HAVE_Alberta" == "xyes"; then
    PARAMS="$PARAMS \"--with-alberta=$PATH_Alberta\""
  fi  
  if test "x$HAVE_Alu3d" == "xyes"; then
    PARAMS="$PARAMS \"--with-alberta=$PATH_Alu3d\""
  fi
  # call the default implementation
  run_default_configure
}
\end{lstlisting}
\end{lst}

The parameter section will be parsed by \dunecontrol will effect
i.e. the order in which the modules are built. The parameters and
their values are seperated by colon. Possible parameters are
\begin{itemize}
\item \texttt{Module} (\em required\em) is the name of the module. The
  name is of the form \texttt{[a-zA-Z0-9\_]+}.
\item \texttt{Depends} (\em required\em) takes a space seperated list
  of required modules. This module is not functional without these
  other modules.
\item \texttt{Suggests} (\em optional\em) takes a space seperated list
  of optional modules. This module is functional without these
  other modules, but can offer further functionality if one or more of
  the suggested modules are found.
\end{itemize}

The command section lets you overload the default implementation
provided by \dunecontrol. For each command \dunecontrol call the
function \texttt{run\_\textit{command}}. The parameters from the
commandline or the opts file are store in the variable
\texttt{\$PARAMS}. If you just want to create additional parameters
you can add these to \texttt{\$PARAMS} and then call the default
implementation of the command via
\texttt{run\_default\_\textit{command}}.

\section{Creating a new Dune module}

\dune modules are packages that offer a certain functionality that can
be used by \dune applications. Therefor \dune modules offer libraries
and/or header files.

In order to create new \dune module, you have to provide 
\begin{itemize}
\item a \dunemodule file\\
  Usually you will only need to specify the parameters \texttt{Module}
  and \texttt{Depends}.
\item an \autogen script\\
  For most of the modules it should be sufficient to copy the \autogen
  from \dunegrid.
\item a \configureac file\\
  Have look at the \configureac in \dunegrid for example. The most
  important part is the call to \texttt{DUNE\_CHECK\_ALL\_M} which
  runs all checks needed for a \dune module, plus the checks for the
  dependencies.
\end{itemize}

A \dune module should comply with the following rules:
\begin{itemize}
\item Documentation is located under \texttt{doc/} and gets
  web-installed under \texttt{BASEDIR/doc/}.
\item \automake includes are located in \dunecommon. To use them, you
  will have to make a symbolic link to \texttt{dune-common/am/} (see
  \ref{am_includes}). The symlink creation should be handled by the
  \autogen (see \ref{autogen.sh}).
\item The \texttt{am/} directory does not get included in the tarball.
\item Header files that can be used by other \dune modules should be
  accessible via \verb!#include <dune/foo/bar.hh>!. In order to work
  with a freshly checkout version of your module you will usually need
  to create a local symbolic link \texttt{dune ->
    \textit{module-direcotry/}}. This link gets created by the
  \texttt{DUNE\_CHECK\_ALL\_M} command of your \configureac. When running
  \texttt{make install} all header files should be installed into
  \texttt{\textit{prefix}/include/dune/}.
\end{itemize}

\section{Creating a new Dune application}

A \dune application does not differ a lot from a \dune module.
The only difference is that it does not offer functionality to other
\dune projects. This make somethings a little bit easier.

In order to create new \dune module, you have to provide 
\begin{itemize}
\item a \dunemodule file\\
  Usually you will only need to specify the parameters \texttt{Module}
  and \texttt{Depends}.
\item an \autogen script\\
  For most of the application the \autogen following further below
  should be sufficient.
\item a \configureac file\\
  The \configureac looks more less the same as for a \dune module
  except that you call \texttt{DUNE\_CHECK\_ALL} instead of
  \texttt{DUNE\_CHECK\_ALL\_M}.
\end{itemize}

\begin{lst}[Example autogen.sh for a \dune application]
\label{example_autogen.sh}
\begin{lstlisting}[language=bash]

#!/bin/sh

set -e

usage () {
    echo "Usage: ./autogen.sh [options]"
    echo "  --ac=, --acversion=VERSION   use a specific VERSION of autoconf"
    echo "  --am=, --amversion=VERSION   use a specific VERSION of automake"
    echo "  -h,    --help                you already found this :-)"
}

for OPT in "$@"; do
    set +e
    # stolen from configure...
    # when no option is set, this returns an error code
    arg=`expr "x$OPT" : 'x[^=]*=\(.*\)'`
    set -e

    case "$OPT" in
	--ac=*|--acversion=*)
			if test "x$arg" == "x"; then
				usage; 
				exit 1;
			fi
			ACVERSION=$arg
			;;
	--am=*|--amversion=*)
			if test "x$arg" == "x"; then
				usage; 
				exit 1;
			fi
			AMVERSION=$arg
			;;
	-h|--help) usage ; exit 0 ;;
	*)
            if test -d "$OPT/m4"; then
              ACLOCAL_FLAGS="$ACLOCAL_FLAGS -I $(cd $OPT/m4; pwd)"
            fi
            if test -d "$OPT/am"; then
              am_dir="$OPT/am"
            fi
            ;;
    esac
done

if test x$1 = "x" ; then
  usage
  exit 0
fi

if test "x$ACLOCAL_FLAGS" = "x"; then
  echo dune-common/m4 not found. Please supply directory!
  usage
  exit 1
fi

if test -d m4 ; then
  ACLOCAL_FLAGS="$ACLOCAL_FLAGS -I m4"
fi

if test "x$AMVERS" != x ; then
  echo Warning: explicitly using automake version $AMVERS
  # binaries are called automake-$AMVERS
  AMVERS="-$AMVERS"
fi

aclocal$AMVERSION $ACLOCAL_FLAGS

libtoolize --automake --force

autoheader$ACVERSION

automake$AMVERSION --add-missing

autoconf$ACVERSION
\end{lstlisting}
\end{lst}

\section{Futher documentation}

\minisec{automake \& Makefile.am}
\texttt{\url{http://www.gnu.org/software/automake/manual/}}\\
The \automake manual describes in detail how to write and maintain a
\makefileam and the usage of \automake.

\minisec{autoconf \& configure.ac}
\texttt{\url{http://www.gnu.org/software/autoconf/manual/}}\\
The \autoconf manual covers the usage of \autoconf and how to write
\configure.ac files (sometimes they are called \texttt{configure.in}).

\minisec{Autoconf Macro Archive}
\texttt{\url{http://autoconf-archive.cryp.to/}}\\
The Autoconf Macro Archive provides macros that can be integrated in
your \configureac in order to search for certain software. These
macros are useful to many software writers using the autoconf tool, but too
specific to be included into autoconf itself.

\minisec{libtool}
\texttt{\url{http://www.gnu.org/software/libtool/manual.html}}\\
The \libtool manual offers further information on the usage of
\libtool package and gives a good overview of the different
problems/aspects of creating portable libraries.

\minisec{autobook}
\texttt{\url{http://sources.redhat.com/autobook/}}\\
The autobook is a complete book describing the GNU toolchain
(\autoconf, \automake and \libtool). It contains many recipies on how
to use the autotools. The book is available as an online 
version.

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
